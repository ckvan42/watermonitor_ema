#include "lora_spi.h"

#include "hal/lora_spi.h"
#include "watermonitor.h"
#include <lmic.h>

#include <sam.h>

//CPOL = 0
//CPHA = 0
//SERCOM1
//DORD = msb first? = 0
//Mosi: generated by master on falling edge of SCK,
//sampled by slave on rising edge of SCK
//Miso: generated by slave on falling edge of SCK
//Transfer always started by NSS going low.
//MSB first (at least address byte)
//Synchronous -> use /2 output
void spi_init( void )
{
	// Set-up chip select
	PORT->Group[0].DIRSET.bit.DIRSET = (1<<18);
	PORT->Group[0].OUTSET.bit.OUTSET = (1<<18);

	//Setting the Software Reset bit to 1
//	SERCOM1->SPI.CTRLA.bit.SWRST = 1;
	SERCOM4->SPI.CTRLA.bit.SWRST = 1;

	//Wait both bits Software Reset from CTRLA and SYNCBUSY are equal to 0
//	while(SERCOM1->SPI.CTRLA.bit.SWRST || SERCOM1->SPI.SYNCBUSY.bit.SWRST);
	while(SERCOM4->SPI.CTRLA.bit.SWRST || SERCOM4->SPI.SYNCBUSY.bit.SWRST);

//	PORT->Group[0].PINCFG[16].bit.PMUXEN = 1;
//	PORT->Group[0].PINCFG[17].bit.PMUXEN = 1;
//	PORT->Group[0].PINCFG[18].bit.PMUXEN = 1;
//	PORT->Group[0].PINCFG[19].bit.PMUXEN = 1;
//	PORT->Group[0].PMUX[8].bit.PMUXE = 0x02;
//	PORT->Group[0].PMUX[8].bit.PMUXO = 0x02;
//	PORT->Group[0].PMUX[9].bit.PMUXE = 0x02;
//	PORT->Group[0].PMUX[9].bit.PMUXO = 0x02;

	PORT->Group[1].PINCFG[10].bit.PMUXEN = 1;
	PORT->Group[1].PINCFG[11].bit.PMUXEN = 1;
	PORT->Group[0].PINCFG[12].bit.PMUXEN = 1;
	PORT->Group[1].PMUX[5].bit.PMUXE = 0x03;
	PORT->Group[1].PMUX[5].bit.PMUXO = 0x03;
	PORT->Group[0].PMUX[6].bit.PMUXE = 0x03;

//	PM->APBCMASK.bit.SERCOM1_ = 1;

	PM->APBCMASK.bit.SERCOM4_ = 1;

	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_SERCOM4_CORE | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_CLKEN;
    //GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_SERCOM1_CORE | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_CLKEN;
    while (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY);

	//Ensure disabled to set flags
//	SERCOM1->SPI.CTRLA.bit.ENABLE = 0;
    SERCOM4->SPI.CTRLA.bit.ENABLE = 0;

//	while(SERCOM1->SPI.SYNCBUSY.bit.ENABLE)
//		{ continue; }

	while(SERCOM4->SPI.SYNCBUSY.bit.ENABLE)
		{ continue; }


//	SERCOM1->SPI.CTRLA.bit.MODE = 0x3; //Master
	SERCOM4->SPI.CTRLA.bit.MODE = 0x3;

//	SERCOM1->SPI.CTRLA.bit.CPOL = 0;
//	SERCOM1->SPI.CTRLA.bit.CPHA = 0;
	SERCOM4->SPI.CTRLA.bit.CPOL = 0;
	SERCOM4->SPI.CTRLA.bit.CPHA = 0;

//	SERCOM1->SPI.CTRLA.bit.FORM = 0x2;	//frame
	SERCOM4->SPI.CTRLA.bit.FORM = 0x2;

//	SERCOM1->SPI.CTRLA.bit.DIPO = 0x3;	//master. di is miso -> DI pad3
//	SERCOM1->SPI.CTRLA.bit.DOPO = 0x0;	//Do is mosi -> do is pad 0
	SERCOM4->SPI.CTRLA.bit.DIPO = 0x0;
	SERCOM4->SPI.CTRLA.bit.DOPO = 0x1;


	//SCK is then pad 1, ss is pad 2

//	SERCOM1->SPI.CTRLB.bit.CHSIZE = 0; //8 bit char
//	SERCOM1->SPI.CTRLA.bit.DORD = 0; 	//msb first
//	SERCOM1->SPI.CTRLB.bit.MSSEN = 1; 	//Hardware-controlled ss
	SERCOM4->SPI.CTRLB.bit.CHSIZE = 0;
	SERCOM4->SPI.CTRLA.bit.DORD = 0;
	SERCOM4->SPI.CTRLB.bit.MSSEN = 0;

//	SERCOM1->SPI.BAUD.bit.BAUD = 255;
			//SystemCoreClock/(2.0*(115200.0f)) - 1; // check correctness of baud

	SERCOM4->SPI.BAUD.bit.BAUD = 255;


	//receiver enable
//	SERCOM1->SPI.CTRLB.bit.RXEN = 1;
	SERCOM4->SPI.CTRLB.bit.RXEN = 1;

	//finally enable
//	SERCOM1->SPI.CTRLA.bit.ENABLE = 1;
	SERCOM4->SPI.CTRLA.bit.ENABLE = 1;

//	while(SERCOM1->SPI.SYNCBUSY.bit.ENABLE)
//		{ continue; }
	while(SERCOM4->SPI.SYNCBUSY.bit.ENABLE && SERCOM4->SPI.SYNCBUSY.bit.CTRLB)
		{ continue; }

}

uint16_t SpiInOut( uint16_t outData )
{
//	SERCOM1->SPI.DATA.bit.DATA = outData; // Writing data into Data register
//
//	while( SERCOM1->SPI.INTFLAG.bit.RXC == 0 )
//	  { continue; }
//
//	return SERCOM1->SPI.DATA.bit.DATA;  // Reading data

	SERCOM4->SPI.DATA.bit.DATA = outData; // Writing data into Data register

	while( SERCOM4->SPI.INTFLAG.bit.RXC == 0 )
	  { continue; }

	volatile uint16_t result = SERCOM4->SPI.DATA.bit.DATA;  // Reading data

	while( SERCOM4->SPI.INTFLAG.bit.TXC == 0 )
	  { continue; }

	return result;
}

void hal_spi_write(u1_t cmd, const u1_t* buf, size_t len)
{
    uint8_t i;

    //NSS = 0;
    PORT->Group[0].OUTCLR.bit.OUTCLR = (1<<18);

    SpiInOut( cmd | 0x80);
    for( i = 0; i < len; i++ )
    {
        SpiInOut( buf[i] );
    }

    //NSS = 1;
    PORT->Group[0].OUTSET.bit.OUTSET = (1<<18);
}

void hal_spi_read(u1_t cmd, u1_t* buf, size_t len)
{
    uint8_t i;

    //NSS = 0;
    PORT->Group[0].OUTCLR.bit.OUTCLR = (1<<18);

    SpiInOut( cmd );
    for( i = 0; i < len; i++ )
    {
        buf[i] = SpiInOut( 0x00 );
    }

    //NSS = 1;
    PORT->Group[0].OUTSET.bit.OUTSET = (1<<18);
}

